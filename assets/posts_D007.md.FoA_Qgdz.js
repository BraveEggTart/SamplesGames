import{_ as e,c as l,o as t,Y as i,a}from"./chunks/framework.BTdFKloG.js";const x=JSON.parse('{"title":"鼠标框选对象2D","description":"","frontmatter":{"title":"鼠标框选对象2D","descript":"一个类似RTS使用鼠标框选单位功能。","date":"2024-04-30T00:00:00.000Z","image":"https://unity.just4dream.club/D007.jpg","index":7,"tags":["⭐️⭐️⭐️⭐️"],"categories":["NavMesh","LineRanderer"]},"headers":[],"relativePath":"posts/D007.md","filePath":"posts/D007.md","lastUpdated":1719732937000}'),o={name:"posts/D007.md"},n=i('<nav class="table-of-contents"><ul><li><a href="#讲解视频链接">讲解视频链接</a></li><li><a href="#如何运行">如何运行</a></li><li><a href="#代码思路">代码思路</a></li><li><a href="#类图设计">类图设计</a></li></ul></nav><h2 id="讲解视频链接" tabindex="-1">讲解视频链接 <a class="header-anchor" href="#讲解视频链接" aria-label="Permalink to &quot;讲解视频链接&quot;">​</a></h2>',2),r=a("iframe",{src:"//player.bilibili.com/player.html?isOutside=true&aid=942667391&bvid=BV1EW4y1b7Mb&cid=823702128&p=1&high_quality=1&danmaku=1&as_wide=1",allowfullscreen:"allowfullscreen",width:"100%",height:"600",scrolling:"no",frameborder:"0",sandbox:"allow-top-navigation allow-same-origin allow-forms allow-scripts"},null,-1),s=i('<h2 id="如何运行" tabindex="-1">如何运行 <a class="header-anchor" href="#如何运行" aria-label="Permalink to &quot;如何运行&quot;">​</a></h2><p>运行示例场景，使用鼠标框选场景中物品，选中的对象会被列在屏幕上。</p><h2 id="代码思路" tabindex="-1">代码思路 <a class="header-anchor" href="#代码思路" aria-label="Permalink to &quot;代码思路&quot;">​</a></h2><p>本功能主要难点有两处</p><ul><li><p>如何在屏幕上画一个矩形</p><ul><li>通过线渲染器来显示线条</li><li>通过点击和抬起事件来获取第一个点和第四个点</li><li>通过1，4点计算出另外两个点</li><li>拿到四个点，绘制矩形。</li></ul></li><li><p>如何检测框选中的对象</p><ul><li>当点击时从摄像机发射一条射线到世界，拿到第一个点</li><li>当抬起时，故技重施，拿到第二个点</li><li>根据起始点和结束点计算矩形区域的<strong>中心点</strong>和<strong>半尺寸</strong><ul><li><p><code>Vector3 center = new Vector3((beginPoint.x + hit.point.x) / 2, 1, (beginPoint.z + hit.point.z) / 2);</code></p><ol><li><code>beginPoint</code>是鼠标按下时射线与场景相交的点,它是矩形框的起始点。</li><li><code>hit.point</code>是鼠标抬起时射线与场景相交的点,它是矩形框的结束点。</li></ol><p>为了获得矩形框的中心点,我们需要计算起始点和结束点在 x 轴和 z 轴上的中点。</p><ul><li><code>(beginPoint.x + hit.point.x) / 2</code> 计算了 x 轴上的中点坐标。</li><li><code>(beginPoint.z + hit.point.z) / 2</code> 计算了 z 轴上的中点坐标。</li><li>而 y 坐标被固定为 1,因为这是一个二维平面上的矩形框。</li></ul></li><li><p><code>Vector3 half = new Vector3(Mathf.Abs(hit.point.x - beginPoint.x) / 2, 1, Mathf.Abs(hit.point.z - beginPoint.z) / 2);</code></p><ol><li><code>Mathf.Abs(hit.point.x - beginPoint.x) / 2</code> 计算了矩形框在 x 轴上的半径。它首先获取起始点和结束点在 x 轴上的距离,然后取绝对值,再除以 2 得到半径。</li><li><code>Mathf.Abs(hit.point.z - beginPoint.z) / 2</code> 计算了矩形框在 z 轴上的半径,原理与 x 轴相同。</li><li>y 轴上的半径被固定为 1,因为这是个二维平面上的矩形框。</li></ol></li></ul></li><li>通过<code>Physics.OverlapBox(center, half);</code>获取碰撞体</li></ul></li></ul><h2 id="类图设计" tabindex="-1">类图设计 <a class="header-anchor" href="#类图设计" aria-label="Permalink to &quot;类图设计&quot;">​</a></h2><p>无</p>',7),c=[n,r,s];function d(h,p,_,u,b,f){return t(),l("div",null,c)}const m=e(o,[["render",d]]);export{x as __pageData,m as default};
